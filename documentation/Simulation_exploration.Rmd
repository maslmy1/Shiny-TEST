---
title: "Simulation Exploration"
author: "Emily Robinson"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, fig.width = 8, fig.height = 4, out.width = "100%", dpi = 300, message = F)
library(tidyverse)
library(gridExtra)
```

*Needs modifications, very sensitive to parameters such as growth coefficient and error variance. See corresponding Shiny application [here](https://emily-robinson.shinyapps.io/SimulationExplorationApp/) to adjust parameters.*

# Estimation

## Manual simulation

### Exponential

```{r expManual, message=FALSE, warning=FALSE}
generateDat_Manual <- 
  function(n, coef, muErr, sdErr, xRange, errorType){
    
    x <- runif(n, xRange[1], xRange[2])
    yRaw   <- exp(coef*x)
    yError <-  rnorm(n, muErr, sdErr)
    if(errorType %in% c("Additive")){
      y      <- yRaw + yError
    } else {
      if(errorType %in% c("Multiplicative")){
        y      <- yRaw*yError 
      }
    }
    
    return(cbind(x, y) %>% as.data.frame())
  }

data_manual <- generateDat_Manual(n = 30, coef = 0.1, muErr = 1, sdErr = 0.25, xRange = c(0,30), errorType = "Additive")
```

```{r, echo = F, expManualPlots}
linearPlot_Manual <- data_manual %>%
                      ggplot(aes(x = x, y = y)) +
                      geom_point() +
                      # geom_smooth(se = F, color = "black", method = loess) + 
                      theme_bw() +
                      ggtitle("Linear Exponential: Manual")  

logPlot_Manual    <- data_manual %>%
                      ggplot(aes(x = x, y = y)) +
                      geom_point() +
                      # geom_smooth(se = F, color = "black", method = loess) +
                      theme_bw() + 
                      scale_y_log10() +
                      ggtitle("Log Exponential: Manual")


grid.arrange(linearPlot_Manual, logPlot_Manual, ncol=2)
```

## library(simglm)

Modify function to accomodate exponential as an outcome type.

```{r simglmModificaiton}
transform_outcome2 <- 
  function (outcome, type, ...) 
{
  if (type %in% c("logistic", "binary")) {
    probability <- exp(outcome)/(1 + exp(outcome))
    rbinom(length(outcome), size = 1, prob = probability)
  } 
  else {
    if (type %in% c("exp", "exponential")) {
      rexp(length(outcome), rate = 1/exp(outcome))
    }
    else {
      if (type %in% c("count", "poisson")) {
        rpois(length(outcome),  lambda = exp(outcome))
      }
      else {
        purrr::map()
      }
    }
  }
}

generate_response2 <- 
  function (data, sim_args, keep_intermediate = TRUE, ...) {
  outcome_name <- parse_formula(sim_args)[["outcome"]]
  outcome_type <- sim_args[["outcome_type"]]
  fixed_formula <- parse_formula(sim_args)[["fixed"]]
  fixed_vars <- attr(terms(fixed_formula), "term.labels")
  if (any(grepl("^factor\\(", fixed_vars))) {
    fixed_vars <- gsub("factor\\(|\\)$", "",
                       fixed_vars)
  }
  if (any(grepl("^ns\\(", fixed_vars))) {
    fixed_vars <- gsub("ns\\(|\\,.+\\)$", "",
                       fixed_vars)
  }
  if (any(grepl("^poly\\(", fixed_vars))) {
    fixed_vars <- gsub("poly\\(|\\,.+\\)", "",
                       fixed_vars)
  }
  if (any(grepl(":", fixed_vars))) {
    fixed_vars <- gsub(":", "\\.", fixed_vars)
  }
  if (any(grepl("^ns|^poly", attr(terms(fixed_formula),
                                  "term.labels")))) {
    fixed_vars <- poly_ns_names(sim_args)
  }
  if (any(unlist(lapply(seq_along(sim_args[["fixed"]]),
                        function(xx) sim_args[["fixed"]][[xx]]$var_type)) ==
          "factor")) {
    num_levels <- lapply(seq_along(sim_args[["fixed"]]),
                         function(xx) sim_args[["fixed"]][[xx]][["levels"]])
    num_levels <- purrr::modify_if(num_levels, is.character,
                                   length)
    if (any(unlist(lapply(seq_along(sim_args[["fixed"]]),
                          function(xx) num_levels[[xx]] > 2 & sim_args[["fixed"]][[xx]][["var_type"]] ==
                          "factor")))) {
      fixed_vars <- factor_names(sim_args, fixed_vars)
    }
  }
  Xmat <- dplyr::select(data, fixed_vars)
  if (any(grepl("Intercept", names(data)))) {
    Xmat <- cbind(data["X.Intercept."], Xmat)
  }
  fixed_outcome <- as.matrix(Xmat) %*% sim_args[["reg_weights"]]
  if (length(parse_formula(sim_args)[["randomeffect"]]) !=
      0) {
    random_formula <- parse_formula(sim_args)[["randomeffect"]]
    random_formula_parsed <- parse_randomeffect(random_formula)
    random_effects_names <- names(sim_args[["randomeffect"]])
    random_formula <- lapply(seq_along(random_formula_parsed[["random_effects"]]),
                             function(xx) as.formula(random_formula_parsed[["random_effects"]][xx]))
    Zmat <- lapply(random_formula, model.matrix, data = data) %>%
      lapply(., data.frame) %>% dplyr::bind_cols()
    rand_effects <- dplyr::select(data, random_effects_names)
    random_effects <- rowSums(rand_effects * Zmat)
  }
  else {
    random_effects <- NULL
    random_effects <- 0
  }
  if (keep_intermediate) {
    response_outcomes <- data.frame(fixed_outcome = fixed_outcome,
                                    random_effects = random_effects)
    data <- cbind(data, response_outcomes, row.names = NULL)
  }
  if (is.null(data[["error"]])) {
    data["error"] <- 0
  }
  outcome <- as.numeric(unlist(fixed_outcome + random_effects +
                                 data["error"]))
  if (!is.null(sim_args[["outcome_type"]])) {
    trans_outcome <- transform_outcome2(outcome, type = sim_args[["outcome_type"]])
    data <- cbind(data, untransformed_outcome = outcome)
    data[outcome_name] <- trans_outcome
  }
  else {
    data[outcome_name] <- outcome
  }
  data
}
```

```{r generateSimglm}
library(simglm)

generateDat_simglm <- 
  function(n, varErr, xRange, regWeights, functionalForm){
    
    if(functionalForm %in% c("Quadratic")){
      sim_arguments <- list(
        formula = y ~ 1 + x1,
        error = list(variance = varErr),
        fixed = list(x1 = list(var_type = 'ordinal', levels = xRange[1]:xRange[2])),
        sample_size = n
      )
      
      sim_arguments2 <- list(
        formula = y ~ 1 + x1 + x2,
        sample_size = n,
        reg_weights = regWeights
      )
      
      return(simulate_fixed(data = NULL, sim_arguments) %>% 
               mutate(x2 = x1*x1) %>%
               simulate_error(sim_arguments) %>%
               generate_response(sim_arguments2)
      )
      
    } else {
      if(functionalForm %in% "Exponential"){
        sim_arguments <- list(
          formula = y ~ 1 + x1,
          error = list(variance = varErr),
          fixed = list(x1 = list(var_type = 'ordinal', levels = xRange[1]:xRange[2])),
          sample_size = n,
          reg_weights = regWeights,
          outcome_type = "exp"
        )
        
        return(simulate_fixed(data = NULL, sim_arguments) %>% 
                 simulate_error(sim_arguments) %>%
                 generate_response2(sim_arguments)
        )
      }
    }
    
  }
```

### Quadratic

```{r quadSimglm, message=FALSE, warning=FALSE}
dat_quadSimglm <- generateDat_simglm(functionalForm = "Quadratic", n = 30, regWeights = c(1, 0.1, 0.5), varErr = 50, xRange = c(0,30))
```

```{r quadSimglmPlots, echo = F, message=FALSE, warning=FALSE}
linearPlot_quadSimglm <- dat_quadSimglm %>%
                    ggplot(aes(x = x1, y = y)) +
                    scale_x_continuous("x") +
                    geom_point() +
                    theme_bw() +
                    ggtitle("Linear Quadratic: simglm")

logPlot_quadSimglm <- dat_quadSimglm %>%
                    ggplot(aes(x = x1, y = y)) +
                    scale_x_continuous("x") +
                    geom_point() +
                    theme_bw() + 
                    scale_y_log10() +
                    ggtitle("Log Quadratic: simglm")

grid.arrange(linearPlot_quadSimglm, logPlot_quadSimglm, ncol=2)
```

### Exponential

```{r expSimglm, message=FALSE, warning=FALSE}
simDat_expSimglm <- generateDat_simglm(functionalForm = "Exponential", n = 30, regWeights = c(1,0.5), varErr = 0.25, xRange = c(0,30))

```

```{r echo = F, expSimglmPlots}
linearPlot_expSimglm <- simDat_expSimglm %>%
                    ggplot(aes(x = x1, y = y)) +
                    scale_x_continuous("x") +
                    geom_point() +
                    theme_bw() +
                    ggtitle("Linear Exponential: simglm")

logPlot_expSimglm <- simDat_expSimglm %>%
                    ggplot(aes(x = x1, y = y)) +
                    scale_x_continuous("x") +
                    geom_point() +
                    theme_bw() + 
                    scale_y_log10() +
                    ggtitle("Log Exponential: simglm")

grid.arrange(linearPlot_expSimglm, logPlot_expSimglm, ncol=2)
```

## "Stroup" Simulation

### Exponential
```{r expStroup, message=FALSE, warning=FALSE}
generateDat_Stroup <- 
  function(n, muErr, sdErr, coef, xRange){
    x <- runif(n, xRange[1], xRange[2])
    e_i <- rnorm(n, muErr, sdErr)
    eta <- x*coef + e_i
    y   <- rexp(length(eta), rate = 1/exp(eta)) 
    return(cbind(x, y) %>% as.data.frame())
  }

dat_expStroup <- generateDat_Stroup(n = 30, coef = 0.5, muErr = 0, sdErr = 0.25, xRange = c(0,30))
```

```{r expStroupPlots, echo = F}
linearPlot_expStroup <- dat_expStroup %>%
                      ggplot(aes(x = x, y = y)) +
                      geom_point() +
                      # geom_smooth(se = F, color = "black", method = loess) + 
                      theme_bw() +
                      ggtitle("Linear Exponential: Stroup")  

logPlot_expStroup    <- dat_expStroup %>%
                      ggplot(aes(x = x, y = y)) +
                      geom_point() +
                      # geom_smooth(se = F, color = "black", method = loess) +
                      theme_bw() + 
                      scale_y_log10() +
                      ggtitle("Linear Exponential: Stroup")


grid.arrange(linearPlot_expStroup, logPlot_expStroup, ncol=2)
```







